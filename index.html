<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Smooth Heavenly Lines - Starry Night Theme</title>
<style>
  body, html {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: black;
    height: 100%;
    width: 100%;
  }
  canvas {
    display: block;
    position: fixed;
    top: 0; left: 0;
  }
  audio {
    display: none; /* hide the player */
  }
  /* Style for the start button container */
  #start-container {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    z-index: 9999;
    background: rgba(0,0,0,0.7);
    padding: 20px;
    border-radius: 10px;
    text-align: center;
  }
  #start-container button {
    padding: 12px 24px;
    font-size: 18px;
    cursor: pointer;
    background: white;
    border: none;
    border-radius: 6px;
  }
</style>
</head>
<body>

<!-- Start Button -->
<div id="start-container">
  <button onclick="startAudio()">Start Calming Sound ðŸŒ™</button>
</div>

<canvas id="canvas"></canvas>

<!-- Calming White Noise Audio -->
<audio id="background-audio" loop>
  <source src="https://cdn.pixabay.com/audio/2022/03/15/audio_cdb1c20316.mp3" type="audio/mpeg">
  Your browser does not support the audio element.
</audio>

<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  let width, height;
  function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  // Stars setup
  const stars = [];
  const STAR_COUNT = 200;

  function initStars() {
    stars.length = 0;
    for (let i = 0; i < STAR_COUNT; i++) {
      stars.push({
        x: Math.random() * width,
        y: Math.random() * height,
        radius: Math.random() * 1.2 + 0.3,
        alpha: Math.random(),
        delta: 0.002 + Math.random() * 0.007
      });
    }
  }
  initStars();

  function drawBackground() {
    const grad = ctx.createRadialGradient(width/2, height/2, 100, width/2, height/2, Math.max(width, height));
    grad.addColorStop(0, '#0b1d51');
    grad.addColorStop(1, '#000011');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, width, height);
  }

  function drawStars() {
    for (const star of stars) {
      star.alpha += star.delta;
      if (star.alpha > 1) {
        star.alpha = 1;
        star.delta *= -1;
      } else if (star.alpha < 0.1) {
        star.alpha = 0.1;
        star.delta *= -1;
      }
      ctx.beginPath();
      ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
      ctx.shadowColor = `rgba(255, 255, 255, ${star.alpha})`;
      ctx.shadowBlur = 6;
      ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  }

  const LINE_LENGTH = 50;
  const MAX_DEPTH = 6;
  const SPEED = 4;

  const directions = ['up', 'down', 'left', 'right'];
  const origin = { x: width / 2, y: height / 2 };

  let queue = [];
  let currentLine = null;
  let completedLines = [];

  function drawDot(x, y, size = 4) {
    ctx.fillStyle = 'white';
    ctx.shadowColor = 'white';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  function drawPartialLine(from, to, progress) {
    const dx = to.x - from.x;
    const dy = to.y - from.y;
    const px = from.x + dx * progress;
    const py = from.y + dy * progress;

    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.shadowColor = 'white';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.moveTo(from.x, from.y);
    ctx.lineTo(px, py);
    ctx.stroke();
    ctx.shadowBlur = 0;
  }

  function getNextPoint(x, y, direction) {
    switch (direction) {
      case 'up': return { x, y: y - LINE_LENGTH };
      case 'down': return { x, y: y + LINE_LENGTH };
      case 'left': return { x: x - LINE_LENGTH, y };
      case 'right': return { x: x + LINE_LENGTH, y };
    }
  }

  function reset() {
    queue = [];
    currentLine = null;
    completedLines = [];
    addBranches(origin, 0);
  }

  function addBranches(point, depth) {
    if (depth >= MAX_DEPTH) return;
    const numBranches = Math.floor(Math.random() * 2) + 2;
    const shuffled = directions.sort(() => Math.random() - 0.5);

    for (let i = 0; i < numBranches; i++) {
      const dir = shuffled[i];
      const to = getNextPoint(point.x, point.y, dir);
      queue.push({ from: point, to, progress: 0, depth });
    }
  }

  function animate() {
    drawBackground();
    drawStars();

    for (const line of completedLines) {
      drawPartialLine(line.from, line.to, 1);
      drawDot(line.to.x, line.to.y, 3);
    }

    if (!currentLine && queue.length > 0) {
      currentLine = queue.shift();
    }

    if (currentLine) {
      currentLine.progress += SPEED / LINE_LENGTH;
      if (currentLine.progress >= 1) {
        currentLine.progress = 1;
        drawPartialLine(currentLine.from, currentLine.to, 1);
        drawDot(currentLine.to.x, currentLine.to.y, 3);

        completedLines.push(currentLine);

        addBranches(currentLine.to, currentLine.depth + 1);
        currentLine = null;
      } else {
        drawPartialLine(currentLine.from, currentLine.to, currentLine.progress);
      }
    }

    if (!currentLine && queue.length === 0) {
      setTimeout(() => {
        reset();
      }, 1000);
    }

    requestAnimationFrame(animate);
  }

  reset();
  animate();

  // Automatically reset animation every 30 seconds
  setInterval(() => {
    reset();
  }, 30000);

  // Function to start audio after user interaction
  function startAudio() {
    const audio = document.getElementById('background-audio');
    audio.play();
    document.getElementById('start-container').style.display = 'none';
  }
</script>

</body>
</html>
