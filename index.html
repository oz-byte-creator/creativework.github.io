<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Smooth Heavenly Lines - Starry Night Theme</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      /* Remove background gradient from body since we're drawing it on canvas */
      background: black;
    }

    canvas {
      display: block;
      filter: drop-shadow(0 0 10px white);
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    function resizeCanvas() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', () => {
      resizeCanvas();
      initStars(); // Re-init stars on resize for full coverage
    });
    resizeCanvas();

    // Create starfield for the background
    const stars = [];
    const STAR_COUNT = 200;

    function initStars() {
      stars.length = 0;
      for (let i = 0; i < STAR_COUNT; i++) {
        stars.push({
          x: Math.random() * width,
          y: Math.random() * height,
          radius: Math.random() * 1.3 + 0.2,
          alpha: Math.random(),
          delta: 0.002 + Math.random() * 0.007
        });
      }
    }

    initStars();

    function drawStars() {
      // Draw radial night sky background on canvas
      const gradient = ctx.createRadialGradient(
        width / 2,
        height / 2,
        100,
        width / 2,
        height / 2,
        Math.max(width, height)
      );
      gradient.addColorStop(0, '#0b1d51'); // deep blue center
      gradient.addColorStop(1, '#000011'); // almost black edges
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);

      // Draw twinkling stars
      for (const star of stars) {
        star.alpha += star.delta;
        if (star.alpha > 1) {
          star.alpha = 1;
          star.delta *= -1;
        } else if (star.alpha < 0.1) {
          star.alpha = 0.1;
          star.delta *= -1;
        }
        ctx.beginPath();
        ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
        ctx.shadowColor = `rgba(255, 255, 255, ${star.alpha})`;
        ctx.shadowBlur = 6;
        ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }
    }

    // Settings for your original line animation
    const LINE_LENGTH = 50;
    const MAX_DEPTH = 6;
    const SPEED = 4; // pixels per frame

    const directions = ['up', 'down', 'left', 'right'];
    const origin = { x: width / 2, y: height / 2 };

    // Animation state
    let queue = [];
    let currentLine = null;

    function drawDot(x, y, size = 4) {
      ctx.fillStyle = 'white';
      ctx.shadowColor = 'white';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawPartialLine(from, to, progress) {
      const dx = to.x - from.x;
      const dy = to.y - from.y;
      const px = from.x + dx * progress;
      const py = from.y + dy * progress;

      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;
      ctx.shadowColor = 'white';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(px, py);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    function getNextPoint(x, y, direction) {
      switch (direction) {
        case 'up': return { x: x, y: y - LINE_LENGTH };
        case 'down': return { x: x, y: y + LINE_LENGTH };
        case 'left': return { x: x - LINE_LENGTH, y: y };
        case 'right': return { x: x + LINE_LENGTH, y: y };
      }
    }

    function reset() {
      queue = [];
      currentLine = null;
      addBranches(origin, 0);
      // drawStars() will be called in animate loop
      drawDot(origin.x, origin.y);
    }

    function addBranches(point, depth) {
      if (depth >= MAX_DEPTH) return;

      const numBranches = Math.floor(Math.random() * 2) + 2; // 2 or 3 branches
      const shuffled = directions.sort(() => Math.random() - 0.5);

      for (let i = 0; i < numBranches; i++) {
        const dir = shuffled[i];
        const to = getNextPoint(point.x, point.y, dir);
        queue.push({
          from: point,
          to: to,
          progress: 0,
          depth: depth
        });
      }
    }

    function animate() {
      drawStars(); // Draw background and stars

      // Draw all fully completed lines and dots â€” 
      // we need to keep track of them so they don't disappear:
      // We'll store them in an array that we draw every frame.
      // Let's add that now:

      // We'll need a global array to store completed lines and dots
      if (!window.completedLines) {
        window.completedLines = [];
      }

      // Draw all completed lines and dots first:
      for (const line of window.completedLines) {
        drawPartialLine(line.from, line.to, 1);
        drawDot(line.to.x, line.to.y, 3);
      }

      if (!currentLine && queue.length > 0) {
        currentLine = queue.shift();
      }

      if (currentLine) {
        currentLine.progress += SPEED / LINE_LENGTH;
        if (currentLine.progress >= 1) {
          currentLine.progress = 1;
          drawPartialLine(currentLine.from, currentLine.to, 1);
          drawDot(currentLine.to.x, currentLine.to.y, 3);

          // Store this completed line so it persists
          window.completedLines.push(currentLine);

          addBranches(currentLine.to, currentLine.depth + 1);
          currentLine = null;
        } else {
          drawPartialLine(currentLine.from, currentLine.to, currentLine.progress);
        }
      }

      if (!currentLine && queue.length === 0) {
        // Reset everything after short pause
        setTimeout(() => {
          window.completedLines = [];
          reset();
        }, 1000);
      }

      requestAnimationFrame(animate);
    }

    reset();
    animate();
  </script>
</body>
</html>
